# karthik_proj Documentation

## Project Overview

`karthik_proj` is a Flask-based application that serves as a simple wrapper for the Google Gemini 2.0 Flash generative language model.  It allows users to submit text prompts and receive responses generated by the Gemini model. The application handles potential API errors through retry mechanisms and includes CORS support for easier integration with front-end applications.  The project leverages environment variables for secure API key management.


## Installation/Setup

1. **Clone the repository:**
   ```bash
   git clone <repository_url>
   ```

2. **Install dependencies:**
   ```bash
   pip install -r requirements.txt
   ```
   *(Note:  A `requirements.txt` file is assumed to exist and contain `Flask`, `flask-cors`, `requests`, and `python-dotenv`.)*

3. **Create a `.env` file:** Create a file named `.env` in the project's root directory and add your Gemini API key:
   ```
   GEMINI_API_KEY=your_gemini_api_key
   ```
   Replace `your_gemini_api_key` with your actual API key from the Google Cloud console.  **Never commit your .env file to version control.**

4. **Run the application:**
   ```bash
   python app.py
   ```
   The application will typically run on `http://127.0.0.1:5000/` (the default Flask port).


## Tech Stack

* **Python:** The primary programming language.
* **Flask:** A lightweight web framework for building the API.
* **requests:**  For making HTTP requests to the Gemini API.
* **flask_cors:** Enables Cross-Origin Resource Sharing (CORS), allowing requests from different domains.
* **python-dotenv:** For loading environment variables from the `.env` file.
* **Google Gemini 2.0 Flash:** The underlying large language model.


## Feature List

* **Prompt Submission:** Accepts text prompts via API requests.
* **Gemini API Integration:**  Uses the Google Gemini 2.0 Flash API to generate text completions.
* **Error Handling:** Includes retry logic to handle potential API failures.
* **CORS Support:** Allows cross-origin requests, facilitating integration with various front-end technologies.
* **Environment Variable Management:** Securely stores the Gemini API key in an environment variable.


## Code Architecture

The application follows a simple structure:

1. **`app.py`:** This file contains the main Flask application. It defines the API endpoint (`/`), which handles incoming prompt requests.
2. **`call_gemini()` function:** This function encapsulates the logic for interacting with the Gemini API. It includes retry logic with exponential backoff to improve resilience.
3. **Environment Variables:** The Gemini API key is stored securely as an environment variable, preventing it from being hardcoded in the source code.


## Usage Examples

To send a prompt to the API, you can use a tool like `curl` or any HTTP client:


**Example using curl:**

```bash
curl -X POST -H "Content-Type: application/json" -d '{"prompt": "Write a short poem about a cat."}' http://127.0.0.1:5000/
```

This will send a POST request to the `/` endpoint with the prompt "Write a short poem about a cat."  The response will contain the generated text from the Gemini model.  Note that the actual endpoint for sending the prompt is not explicitly defined in the provided code, it's implied to be the root URL ("/").  A more robust implementation would likely define a specific endpoint (e.g., `/generate`).


## APIs or Functions Explained

**`call_gemini(prompt, max_retries=5)`:**

This function is the core of the application. It takes a `prompt` (string) as input and optionally the maximum number of retries (`max_retries`). It constructs the request to the Gemini API, sends it, and handles the response:

* **Error Handling:**  The function attempts to send the request up to `max_retries` times.  If the request fails (non-2xx status code), it waits an exponentially increasing amount of time before retrying.
* **Response Processing:** If the request is successful, it extracts the generated text from the JSON response and returns it.
* **Exponential Backoff:** The delay between retries increases with each attempt, helping to avoid overwhelming the API during transient errors.


**Missing Aspects:**  The provided code snippet lacks error handling for cases where the JSON response from the Gemini API is malformed or missing expected keys.  A production-ready application should include more robust error handling and logging.  Further,  the code doesn't show how the `/` endpoint handles incoming requests and interacts with the `call_gemini` function.  Adding these aspects would improve the completeness of the documentation.
